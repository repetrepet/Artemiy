from itertools import product

# ==============================================================================
# ЗАДАЧА 1: Кодовый замок (Поиск количества перестановок с условием)
# ==============================================================================
# Шифр кодового замка представляет собой последовательность из пяти символов, 
# каждый из которых является цифрой от 1 до 4. Сколько различных вариантов 
# шифра можно задать, если известно, что цифра 1 встречается ровно два раза, 
# а каждая из других допустимых цифр может встречаться в шифре любое 
# количество раз или не встречаться совсем?

alph = '1234' # Алфавит допустимых символов (цифры от 1 до 4)
l = []        # Список для сохранения подходящих вариантов (можно и просто счетчик использовать)

# product(alph, repeat=5) генерирует все возможные комбинации длиной 5
# Это аналог 5 вложенных циклов for
for i in product(alph, repeat=5):
    # i — это кортеж символов, например ('1', '2', '1', '4', '3')
    
    # Метод .count('1') считает количество единиц в кортеже
    if i.count('1') == 2:
        l.append(i) # Если условие выполнено, добавляем вариант в список

print(f"Задача 1: {len(l)}")


# ==============================================================================
# ЗАДАЧА 2: Четверичная система (Числа и арифметические условия)
# ==============================================================================
# Сколько существует различных трёхзначных чисел, записанных в четверичной 
# системе счисления, в записи которых сумма первой и последней цифры строго 
# больше цифры стоящей по середине?

aplh = '0123' # Алфавит четверичной системы
l = []

# Генерируем все возможные тройки цифр
for i in product(aplh, repeat=3):
    # i[0] — первая цифра, i[1] — вторая, i[2] — третья
    
    # Условие 1: i[0] != '0'. Число не может начинаться с нуля.
    # Условие 2: Сумма крайних > средней.
    # Важно: элементы i — это строки ('0', '1'...), поэтому для математики 
    # их нужно преобразовать в числа через int()
    if (i[0] != '0') and (int(i[0]) + int(i[2]) > int(i[1])):
        l.append(i)

print(f"Задача 2: {len(l)}")


# ==============================================================================
# ЗАДАЧА 3: Семеричная система (Убывающий порядок цифр)
# ==============================================================================
# Сколько существует различных четырёхзначных чисел, записанных в семеричной 
# системе счисления, в записи которых цифры следуют слева направо в строго 
# убывающем порядке?

aplhabet = '0123456' # Алфавит семеричной системы
l = []

# Генерируем 4-значные комбинации
for i in product(aplhabet, repeat=4):
    # Числа должны строго убывать: 1-е > 2-го > 3-го > 4-го.
    # В Python строки сравниваются лексикографически, что для цифр 0-9 
    # совпадает с числовым сравнением (т.е. '5' > '4' дает True).
    # Здесь не нужно проверять i[0] != '0', так как при строгом убывании
    # ноль никогда не окажется на первом месте (меньше нуля в алфавите ничего нет).
    if i[0] > i[1] > i[2] > i[3]:
        l.append(i)

print(f"Задача 3: {len(l)}")


# ==============================================================================
# ЗАДАЧА 4: Слова из букв (Ограничения на буквы)
# ==============================================================================
# Составляют 5-буквенные слова из букв слова ПЯТНИЦА. Найти количество слов, 
# которые не начинаются с Н и в которых есть только одна буква Я. 
# Буквы в слове могут повторяться.

count = 0 # Используем простой счетчик вместо списка

# repeat=5, так как слова 5-буквенные
for i in product('ПЯТНИЦА', repeat=5):
    # i[0] != 'Н' — слово не начинается на Н
    # i.count('Я') == 1 — буква Я встречается ровно один раз
    if i[0] != 'Н' and i.count('Я') == 1:
        count += 1

print(f"Задача 4: {count}")


# Сколько существует десятичных чисел, которые делятся на 5, при условии что все цифры числа различные?

# Идея задачи:
# - Число в десятичной системе делится на 5 тогда и только тогда, когда его последняя цифра 0 или 5.
# - Все цифры должны быть различными, значит мы можем составлять числа как перестановки цифр без повторений.
# - Длина числа может быть от 1 до 10 (больше нельзя, потому что всего 10 разных цифр).
# - Первой цифрой не может быть 0, иначе это не будет "десятичное число" заданной длины (получится запись с ведущим нулём).

from itertools import permutations

alph = '0123456789'  # алфавит цифр десятичной системы
count = 0            # сюда накапливаем количество подходящих чисел

# Перебираем все возможные длины числа: 1, 2, ..., 10
for length in range(1, 11):

  # permutations(alph, length) возвращает все кортежи длины length
  # из РАЗНЫХ символов (без повторений), т.е. все перестановки длины length
  for j in permutations(alph, length):

    # Условия:
    # 1) j[0] != '0'  — запрещаем ведущий ноль
    # 2) j[-1] == '5' или j[-1] == '0' — последняя цифра 0/5 => число делится на 5
    if j[0] != '0' and (j[-1] == '5' or j[-1] == '0'):
      count += 1

print(count)



# Сколько существует шестнадцатеричных четырёхзначных чисел, содержащих в своей записи ровно одну цифру 3, в которых никакие две одинаковые цифры не стоят рядом?

# Идея задачи:
# - Шестнадцатеричное число четырёхзначное: первая цифра не должна быть 0.
# - Используем алфавит hex: 0-9 и a-f.
# - "Никакие две одинаковые цифры не стоят рядом" означает:
#   i[0] != i[1], i[1] != i[2], i[2] != i[3].
#   (Важно: одинаковые цифры могут встретиться, но НЕ рядом. Например, 'a0a1' разрешено.)
# - "Ровно одна цифра 3" означает count('3') == 1.

from itertools import product

alph = '0123456789abcdef'  # алфавит шестнадцатеричной системы
count = 0                  # счётчик подходящих четырёхзначных hex-чисел

# product(alph, repeat=4) перебирает ВСЕ 4-символьные последовательности из alph
# (то есть с повторами тоже), всего 16^4 вариантов.
for i in product(alph, repeat=4):

  # Условие четырёхзначности: первый символ не ноль
  if i[0] != '0':

    # Проверяем запрет на одинаковые соседние цифры
    # (соседние пары: (0,1), (1,2), (2,3))
    if i[0] != i[1] and i[1] != i[2] and i[2] != i[3]:

      # Ровно одна цифра '3' в записи
      if i.count('3') == 1:
        count += 1

print(count)
