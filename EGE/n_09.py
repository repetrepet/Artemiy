# Задача 1: Выясните, какое количество троек чисел может являться сторонами треугольника,
# то есть удовлетворяет неравенству треугольника. В ответе запишите только число.

cnt = 0  # Счетчик треугольников
f = open('9.csv')  # Открываем файл с данными

for s in f:  # Проходим по каждой строке файла
    a = list(map(int, s.split(',')))  # Разделяем строку по запятым и преобразуем в список целых чисел
    a.sort()  # Сортируем числа по возрастанию
    
    # Неравенство треугольника: сумма двух меньших сторон должна быть больше третьей
    # После сортировки достаточно проверить: a[0] + a[1] > a[2]
    # Эквивалентно: a[-1] < a[0] + a[1], где a[-1] - самая большая сторона
    if a[-1] < a[0] + a[1]:
        cnt += 1  # Увеличиваем счетчик, если тройка образует треугольник

print(cnt)  # Выводим количество найденных треугольников


# ============================================================================


# Задача 2: Определите количество строк таблицы, в которых квадрат суммы максимального и
# минимального чисел в строке больше суммы квадратов трёх оставшихся.

cnt = 0  # Счетчик строк, удовлетворяющих условию
f = open('table.txt')  # Открываем файл с таблицей

for s in f:  # Проходим по каждой строке файла
    a = list(map(int, s.split()))  # Разделяем строку по пробелам и преобразуем в список целых чисел
    a.sort()  # Сортируем числа по возрастанию
    
    # Проверяем условие: (min + max)² > остальные²
    # После сортировки: a[0] - минимум, a[-1] - максимум
    # Остальные три числа: a[1], a[2], a[3]
    if (a[0] + a[-1]) ** 2 > a[1] ** 2 + a[2] ** 2 + a[3] ** 2:
        cnt += 1  # Увеличиваем счетчик, если условие выполнено

print(cnt)  # Выводим количество найденных строк


# ============================================================================


# Задача 3: Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
# — в строке только одно число повторяется ровно два раза, остальные числа различны;
# — среднее арифметическое неповторяющихся чисел строки не больше суммы повторяющихся чисел.

count = 0  # Счетчик строк, удовлетворяющих условиям
f = open('table.txt')  # Открываем файл с таблицей

for s in f:  # Проходим по каждой строке файла
    a = list(map(int, s.split()))  # Разделяем строку по пробелам и преобразуем в список целых чисел
    
    # Создаем список чисел, которые встречаются ровно 2 раза
    # Например, для [1, 2, 3, 3, 4, 5] получим [3, 3]
    povt = [i for i in a if a.count(i) == 2]
    
    # Создаем список чисел, которые встречаются ровно 1 раз
    # Например, для [1, 2, 3, 3, 4, 5] получим [1, 2, 4, 5]
    nepovt = [i for i in a if a.count(i) == 1]
    
    # Проверяем первое условие: ровно одно число повторяется два раза
    # len(povt) == 2 означает, что есть ровно 2 одинаковых числа
    # len(set(nepovt)) == len(nepovt) проверяет, что остальные числа различны
    if len(povt) == 2 and len(set(nepovt)) == len(nepovt):
        
        # Проверяем второе условие: среднее арифметическое неповторяющихся ≤ сумма повторяющихся
        # Проверка len(nepovt) != 0 предотвращает деление на ноль
        if len(nepovt) != 0 and sum(nepovt) / len(nepovt) <= sum(povt):
            count += 1  # Увеличиваем счетчик, если оба условия выполнены

print(count)  # Выводим количество найденных строк


# ============================================================================


# Задача 4: Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
# — каждое число в строке встречается по одному разу,
# — утроенная сумма максимального и минимального значений не превышает удвоенной суммы оставшихся чисел.

count = 0  # Счетчик строк, удовлетворяющих условиям
f = open('table.txt')  # Открываем файл с таблицей

for s in f:  # Проходим по каждой строке файла
    a = list(map(int, s.split()))  # Разделяем строку по пробелам и преобразуем в список целых чисел
    
    # Проверяем первое условие: все числа уникальны
    # len(a) == len(set(a)) означает, что количество элементов равно количеству уникальных элементов
    if len(a) == len(set(a)):
        
        # Проверяем второе условие: 3(max + min) ≤ 2(сумма остальных)
        # sum(a) - max(a) - min(a) = сумма оставшихся трех чисел (всего 5 чисел в строке)
        if 3 * (max(a) + min(a)) <= 2 * (sum(a) - max(a) - min(a)):
            count += 1  # Увеличиваем счетчик, если оба условия выполнены

print(count)  # Выводим количество найденных строк



# Откройте файл электронной таблицы, содержащей в каждой строке пять натуральных чисел.
#
# Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
#
# — каждое число в строке встречается по одному разу,
#
# — утроенная сумма максимального и минимального значений не превышает удвоенной суммы оставшихся чисел.
#
# В ответе запишите только число.

f = open('data.txt')
count = 0

for line in f:
    # Преобразуем строку из файла в список целых чисел
    lst = list(map(int, line.split()))

    # УСЛОВИЕ 1: Все числа различны.
    # Если длина списка равна длине множества (set удаляет дубликаты),
    # значит, все числа в строке уникальны.
    if len(lst) == len(set(lst)):
        
        # Сортируем список по возрастанию. 
        # Теперь lst[0] — это минимум, а lst[-1] (последний) — это максимум.
        lst.sort()
        
        # Максимум и минимум мы нашли (индексы 0 и -1).
        # Оставшиеся числа — это элементы с индексами 1, 2 и 3 (середина списка).
        
        # УСЛОВИЕ 2: 3 * (min + max) <= 2 * (сумма остальных)
        min_max_sum = lst[0] + lst[-1]
        rest_sum = lst[1] + lst[2] + lst[3]
        
        if 3 * min_max_sum <= 2 * rest_sum:
            count += 1

print(count)



# Откройте файл электронной таблицы, содержащей в каждой строке шесть натуральных чисел. 
# Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
#
# — в строке есть только два равных числа, остальные 4 различны;
#
# — среднее арифметическое повторяющихся чисел меньше, чем среднее арифметическое остальных чисел строки.
#
# В ответе запишите только число.

f = open('data.txt')
count = 0  # Счётчик строк, удовлетворяющих условиям

for line in f:
    # Преобразуем строку файла в список целых чисел
    lst = [int(x) for x in line.split()]
    
    # Выделяем повторяющиеся числа (те, которые встречаются ровно 2 раза)
    pov = [x for x in lst if lst.count(x) == 2]
    
    # Выделяем неповторяющиеся числа (те, которые встречаются ровно 1 раз)
    nepov = [x for x in lst if lst.count(x) == 1]
    
    # Проверяем первое условие:
    # len(pov) == 2 означает, что есть ровно одна пара одинаковых чисел
    # len(nepov) == 4 означает, что остальные 4 числа различны
    if len(pov) == 2 and len(nepov) == 4:
        # Проверяем второе условие:
        # Среднее арифметическое повторяющихся чисел < среднего арифметического неповторяющихся
        if sum(pov) / len(pov) < sum(nepov) / len(nepov):
            count += 1  # Увеличиваем счётчик, если оба условия выполнены

print(count)


# ============================================================================


# Откройте файл электронной таблицы, содержащей в каждой строке восемь натуральных чисел. 
# Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
#
# - в строке минимальное число встречается два или три раза, остальные числа без повторений;
#
# - сумма квадратов минимального и максимального из неповторяющихся чисел не больше 
#   квадрата суммы других неповторяющихся.
#
# В ответе запишите только число.

f = open('data.txt')
count = 0  # Счётчик строк, удовлетворяющих условиям

for line in f:
    # Преобразуем строку файла в список целых чисел
    lst = [int(x) for x in line.split()]
    
    # Выделяем повторяющиеся числа, которые являются минимальными и встречаются 2 или 3 раза
    pov = [x for x in lst if 2 <= lst.count(x) <= 3 and x == min(lst)]
    
    # Выделяем неповторяющиеся числа (встречаются ровно 1 раз)
    nepov = [x for x in lst if lst.count(x) == 1]
    
    # Проверяем первое условие:
    # (len(pov) == 2 and len(nepov) == 6) - минимум встречается 2 раза, остальные 6 чисел уникальны
    # (len(pov) == 3 and len(nepov) == 5) - минимум встречается 3 раза, остальные 5 чисел уникальны
    if (len(pov) == 2 and len(nepov) == 6) or (len(pov) == 3 and len(nepov) == 5):
        # Проверяем второе условие:
        # min(nepov)² + max(nepov)² ≤ (сумма остальных неповторяющихся)²
        # "Остальные" = все неповторяющиеся минус минимальное и максимальное
        if min(nepov) ** 2 + max(nepov) ** 2 < (sum(nepov) - min(nepov) - max(nepov)) ** 2:
            count += 1  # Увеличиваем счётчик, если оба условия выполнены

print(count)


# ============================================================================


# В каждой строке электронной таблицы записаны восемь натуральных чисел.
#
# Число в строке считается заметным, если оно строго больше среднего арифметического всех чисел строки.
#
# Определите количество строк таблицы, для которых одновременно выполнены следующие условия:
#
# — количество заметных чётных чисел в строке больше количества заметных нечётных чисел в строке;
#
# — сумма всех чётных чисел строки меньше суммы всех нечётных чисел строки.

f = open('data.txt')
count = 0  # Счётчик строк, удовлетворяющих условиям

for line in f:
    # Преобразуем строку файла в список целых чисел
    lst = [int(x) for x in line.split()]
    
    # Находим заметные числа - те, которые строго больше среднего арифметического
    zam = [x for x in lst if x > sum(lst) / len(lst)]
    
    # Выделяем все чётные числа в строке
    chet_in_lst = [x for x in lst if x % 2 == 0]
    
    # Выделяем все нечётные числа в строке
    nechet_in_lst = [x for x in lst if x % 2 != 0]
    
    # Выделяем заметные чётные числа
    chet_in_zam = [x for x in zam if x % 2 == 0]
    
    # Выделяем заметные нечётные числа
    nechet_in_zam = [x for x in zam if x % 2 != 0]
    
    # Проверяем первое условие:
    # Количество заметных чётных > количества заметных нечётных
    if len(chet_in_zam) > len(nechet_in_zam):
        # Проверяем второе условие:
        # Сумма всех чётных < суммы всех нечётных
        if sum(chet_in_lst) < sum(nechet_in_lst):
            count += 1  # Увеличиваем счётчик, если оба условия выполнены

print(count)



# ========================================================================================
# ЗАДАЧА 1
# ========================================================================================
# Условие:
# Откройте файл электронной таблицы, содержащей в каждой строке четыре натуральных числа.
# Определите количество строк таблицы, содержащих числа, для которых выполнены оба условия:
# — наибольшее из 4 чисел меньше суммы трёх других;
# — все четыре числа различны.

f = open('data.txt') # Открываем файл с данными
count = 0            # Инициализируем счетчик подходящих строк

# Перебираем файл построчно
for line in f:
    # Преобразуем строку из файла в список целых чисел:
    # 1. line.split() разбивает строку по пробелам.
    # 2. int(i) превращает каждый кусок текста в число.
    lst = [int(i) for i in line.split()]
    
    # Сортируем список по возрастанию. 
    # Это позволяет легко найти наибольшее число (оно окажется в конце списка, индекс -1),
    # а остальные три будут в начале (индексы 0, 1, 2).
    lst.sort()
    
    # Проверка первого условия:
    # Наибольшее число (lst[-1]) должно быть меньше суммы трех других.
    # Это условие существования четырехугольника (аналог неравенства треугольника).
    if lst[-1] < lst[0] + lst[1] + lst[2]:
        
        # Проверка второго условия: все числа различны.
        # set(lst) создает множество из элементов списка. Множество удаляет дубликаты.
        # Если длина списка равна длине множества, значит, дубликатов не было.
        if len(lst) == len(set(lst)):
            count += 1 # Если оба условия верны, увеличиваем счетчик

print(count) # Выводим ответ к первой задаче


# ========================================================================================
# ЗАДАЧА 2
# ========================================================================================
# Условие:
# Откройте файл электронной таблицы, содержащей в каждой строке шесть натуральных чисел.
# Определите сумму чисел в строке таблицы с наибольшим номером, содержащей числа, для которых
# выполнены оба условия:
# — в строке все числа расположены в порядке возрастания;
# — количество чётных и нечётных чисел в строке одинаково.

f = open('data.txt')
result = [] # Список для сохранения сумм подходящих строк

for line in f:
    lst = [int(i) for i in line.split()]
    
    # Проверка первого условия: числа идут строго по возрастанию.
    # Сравниваем элементы напрямую по индексам.
    # Можно также было написать: if lst == sorted(lst) and len(set(lst)) == len(lst) 
    # (но в задаче не сказано про строгое возрастание, однако пример a < b < c подразумевает строгость).
    # Здесь используется цепочное сравнение Python.
    if lst[0] < lst[1] < lst[2] < lst[3] < lst[4] < lst[5]:
        
        # Формируем списки четных и нечетных чисел с помощью генераторов списков
        chet = [i for i in lst if i % 2 == 0]
        nechet = [i for i in lst if i % 2 != 0]
        
        # Проверка второго условия: количество четных равно количеству нечетных.
        # Так как всего чисел 6, то должно быть по 3 тех и других.
        if len(chet) == len(nechet):
            # Если строка подходит, добавляем сумму её чисел в список result.
            # Так как мы читаем файл сверху вниз, строки с большими номерами будут добавляться позже.
            result.append(sum(lst))

# Нам нужна сумма чисел строки с НАИБОЛЬШИМ номером.
# Последний добавленный элемент в список result соответствует строке с максимальным номером,
# которая встретилась при чтении файла.
print(result[-1])


# ========================================================================================
# ЗАДАЧА 3
# ========================================================================================
# Условие:
# В файле находится таблица, которая содержит в каждой из строк по 7 натуральных чисел. Найдите
# количество таких строк, в которых два числа повторяются по 2 раза, а 3 других различны,
# среднее арифметическое неповторяющихся чисел меньше среднего арифметического повторяющихся.

# Пример строки, которая подходит под структуру чисел: [1, 1, 2, 2, 3, 4, 5]
# Повторяющиеся (pov): [1, 1, 2, 2] -> 4 элемента
# Неповторяющиеся (nepov): [3, 4, 5] -> 3 элемента

f = open('data.txt')
count = 0

for line in f:
    lst = [int(i) for i in line.split()]
    
    # Используем метод count(), чтобы найти числа, встречающиеся ровно 2 раза.
    # В список pov попадут все вхождения таких чисел.
    # Например, для [1, 1, 2, 2, 3, 4, 5] список pov будет [1, 1, 2, 2].
    pov = [i for i in lst if lst.count(i) == 2]
    
    # Находим уникальные числа (встречаются ровно 1 раз).
    nepov = [i for i in lst if lst.count(i) == 1]
    
    # Проверка структуры чисел:
    # Должно быть два числа по 2 раза (итого 4 элемента в pov)
    # И три числа по 1 разу (итого 3 элемента в nepov)
    # 4 + 3 = 7 чисел всего.
    if len(pov) == 4 and len(nepov) == 3:
        
        # Проверка условия на среднее арифметическое.
        # Ср. арифм = (Сумма элементов) / (Количество элементов).
        sr_nepov = sum(nepov) / len(nepov)
        sr_pov = sum(pov) / len(pov)
        
        if sr_nepov < sr_pov:
            count += 1
            
print(count)
